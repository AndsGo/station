// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: station.proto

package station

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Users_AddUsers_FullMethodName    = "/station.Users/addUsers"
	Users_UpdateUsers_FullMethodName = "/station.Users/updateUsers"
	Users_DeleteUsers_FullMethodName = "/station.Users/deleteUsers"
	Users_QueryUsers_FullMethodName  = "/station.Users/queryUsers"
	Users_GetUsers_FullMethodName    = "/station.Users/getUsers"
)

// UsersClient is the client API for Users service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UsersClient interface {
	AddUsers(ctx context.Context, in *UsersInfo, opts ...grpc.CallOption) (*UsersInfo, error)
	UpdateUsers(ctx context.Context, in *UsersInfo, opts ...grpc.CallOption) (*UsersInfo, error)
	DeleteUsers(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error)
	QueryUsers(ctx context.Context, in *UsersReq, opts ...grpc.CallOption) (*UsersListInfo, error)
	GetUsers(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*UsersInfo, error)
}

type usersClient struct {
	cc grpc.ClientConnInterface
}

func NewUsersClient(cc grpc.ClientConnInterface) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) AddUsers(ctx context.Context, in *UsersInfo, opts ...grpc.CallOption) (*UsersInfo, error) {
	out := new(UsersInfo)
	err := c.cc.Invoke(ctx, Users_AddUsers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UpdateUsers(ctx context.Context, in *UsersInfo, opts ...grpc.CallOption) (*UsersInfo, error) {
	out := new(UsersInfo)
	err := c.cc.Invoke(ctx, Users_UpdateUsers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) DeleteUsers(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error) {
	out := new(BaseDataInfo)
	err := c.cc.Invoke(ctx, Users_DeleteUsers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) QueryUsers(ctx context.Context, in *UsersReq, opts ...grpc.CallOption) (*UsersListInfo, error) {
	out := new(UsersListInfo)
	err := c.cc.Invoke(ctx, Users_QueryUsers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetUsers(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*UsersInfo, error) {
	out := new(UsersInfo)
	err := c.cc.Invoke(ctx, Users_GetUsers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsersServer is the server API for Users service.
// All implementations must embed UnimplementedUsersServer
// for forward compatibility
type UsersServer interface {
	AddUsers(context.Context, *UsersInfo) (*UsersInfo, error)
	UpdateUsers(context.Context, *UsersInfo) (*UsersInfo, error)
	DeleteUsers(context.Context, *IDPathReq) (*BaseDataInfo, error)
	QueryUsers(context.Context, *UsersReq) (*UsersListInfo, error)
	GetUsers(context.Context, *IDPathReq) (*UsersInfo, error)
	mustEmbedUnimplementedUsersServer()
}

// UnimplementedUsersServer must be embedded to have forward compatible implementations.
type UnimplementedUsersServer struct {
}

func (UnimplementedUsersServer) AddUsers(context.Context, *UsersInfo) (*UsersInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUsers not implemented")
}
func (UnimplementedUsersServer) UpdateUsers(context.Context, *UsersInfo) (*UsersInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUsers not implemented")
}
func (UnimplementedUsersServer) DeleteUsers(context.Context, *IDPathReq) (*BaseDataInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUsers not implemented")
}
func (UnimplementedUsersServer) QueryUsers(context.Context, *UsersReq) (*UsersListInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUsers not implemented")
}
func (UnimplementedUsersServer) GetUsers(context.Context, *IDPathReq) (*UsersInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedUsersServer) mustEmbedUnimplementedUsersServer() {}

// UnsafeUsersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsersServer will
// result in compilation errors.
type UnsafeUsersServer interface {
	mustEmbedUnimplementedUsersServer()
}

func RegisterUsersServer(s grpc.ServiceRegistrar, srv UsersServer) {
	s.RegisterService(&Users_ServiceDesc, srv)
}

func _Users_AddUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).AddUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_AddUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).AddUsers(ctx, req.(*UsersInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UpdateUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UpdateUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_UpdateUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UpdateUsers(ctx, req.(*UsersInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_DeleteUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).DeleteUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_DeleteUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).DeleteUsers(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_QueryUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).QueryUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_QueryUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).QueryUsers(ctx, req.(*UsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetUsers(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Users_ServiceDesc is the grpc.ServiceDesc for Users service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Users_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "station.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addUsers",
			Handler:    _Users_AddUsers_Handler,
		},
		{
			MethodName: "updateUsers",
			Handler:    _Users_UpdateUsers_Handler,
		},
		{
			MethodName: "deleteUsers",
			Handler:    _Users_DeleteUsers_Handler,
		},
		{
			MethodName: "queryUsers",
			Handler:    _Users_QueryUsers_Handler,
		},
		{
			MethodName: "getUsers",
			Handler:    _Users_GetUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "station.proto",
}

const (
	Station_AddStation_FullMethodName    = "/station.Station/addStation"
	Station_UpdateStation_FullMethodName = "/station.Station/updateStation"
	Station_DeleteStation_FullMethodName = "/station.Station/deleteStation"
	Station_QueryStation_FullMethodName  = "/station.Station/queryStation"
	Station_GetStationAll_FullMethodName = "/station.Station/getStationAll"
	Station_GetStation_FullMethodName    = "/station.Station/getStation"
	Station_QueryPosts_FullMethodName    = "/station.Station/queryPosts"
)

// StationClient is the client API for Station service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StationClient interface {
	AddStation(ctx context.Context, in *StationInfo, opts ...grpc.CallOption) (*StationInfo, error)
	UpdateStation(ctx context.Context, in *StationInfo, opts ...grpc.CallOption) (*StationInfo, error)
	DeleteStation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error)
	QueryStation(ctx context.Context, in *StationReq, opts ...grpc.CallOption) (*StationListInfo, error)
	GetStationAll(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*StationListInfo, error)
	GetStation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*StationInfo, error)
	QueryPosts(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*StationPostsResp, error)
}

type stationClient struct {
	cc grpc.ClientConnInterface
}

func NewStationClient(cc grpc.ClientConnInterface) StationClient {
	return &stationClient{cc}
}

func (c *stationClient) AddStation(ctx context.Context, in *StationInfo, opts ...grpc.CallOption) (*StationInfo, error) {
	out := new(StationInfo)
	err := c.cc.Invoke(ctx, Station_AddStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) UpdateStation(ctx context.Context, in *StationInfo, opts ...grpc.CallOption) (*StationInfo, error) {
	out := new(StationInfo)
	err := c.cc.Invoke(ctx, Station_UpdateStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) DeleteStation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error) {
	out := new(BaseDataInfo)
	err := c.cc.Invoke(ctx, Station_DeleteStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) QueryStation(ctx context.Context, in *StationReq, opts ...grpc.CallOption) (*StationListInfo, error) {
	out := new(StationListInfo)
	err := c.cc.Invoke(ctx, Station_QueryStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStationAll(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*StationListInfo, error) {
	out := new(StationListInfo)
	err := c.cc.Invoke(ctx, Station_GetStationAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*StationInfo, error) {
	out := new(StationInfo)
	err := c.cc.Invoke(ctx, Station_GetStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) QueryPosts(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*StationPostsResp, error) {
	out := new(StationPostsResp)
	err := c.cc.Invoke(ctx, Station_QueryPosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StationServer is the server API for Station service.
// All implementations must embed UnimplementedStationServer
// for forward compatibility
type StationServer interface {
	AddStation(context.Context, *StationInfo) (*StationInfo, error)
	UpdateStation(context.Context, *StationInfo) (*StationInfo, error)
	DeleteStation(context.Context, *IDPathReq) (*BaseDataInfo, error)
	QueryStation(context.Context, *StationReq) (*StationListInfo, error)
	GetStationAll(context.Context, *IDPathReq) (*StationListInfo, error)
	GetStation(context.Context, *IDPathReq) (*StationInfo, error)
	QueryPosts(context.Context, *IDPathReq) (*StationPostsResp, error)
	mustEmbedUnimplementedStationServer()
}

// UnimplementedStationServer must be embedded to have forward compatible implementations.
type UnimplementedStationServer struct {
}

func (UnimplementedStationServer) AddStation(context.Context, *StationInfo) (*StationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddStation not implemented")
}
func (UnimplementedStationServer) UpdateStation(context.Context, *StationInfo) (*StationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStation not implemented")
}
func (UnimplementedStationServer) DeleteStation(context.Context, *IDPathReq) (*BaseDataInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStation not implemented")
}
func (UnimplementedStationServer) QueryStation(context.Context, *StationReq) (*StationListInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStation not implemented")
}
func (UnimplementedStationServer) GetStationAll(context.Context, *IDPathReq) (*StationListInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStationAll not implemented")
}
func (UnimplementedStationServer) GetStation(context.Context, *IDPathReq) (*StationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStation not implemented")
}
func (UnimplementedStationServer) QueryPosts(context.Context, *IDPathReq) (*StationPostsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPosts not implemented")
}
func (UnimplementedStationServer) mustEmbedUnimplementedStationServer() {}

// UnsafeStationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StationServer will
// result in compilation errors.
type UnsafeStationServer interface {
	mustEmbedUnimplementedStationServer()
}

func RegisterStationServer(s grpc.ServiceRegistrar, srv StationServer) {
	s.RegisterService(&Station_ServiceDesc, srv)
}

func _Station_AddStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).AddStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_AddStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).AddStation(ctx, req.(*StationInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_UpdateStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).UpdateStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_UpdateStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).UpdateStation(ctx, req.(*StationInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_DeleteStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).DeleteStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_DeleteStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).DeleteStation(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_QueryStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).QueryStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_QueryStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).QueryStation(ctx, req.(*StationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStationAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStationAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetStationAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStationAll(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStation(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_QueryPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).QueryPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_QueryPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).QueryPosts(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Station_ServiceDesc is the grpc.ServiceDesc for Station service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Station_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "station.Station",
	HandlerType: (*StationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addStation",
			Handler:    _Station_AddStation_Handler,
		},
		{
			MethodName: "updateStation",
			Handler:    _Station_UpdateStation_Handler,
		},
		{
			MethodName: "deleteStation",
			Handler:    _Station_DeleteStation_Handler,
		},
		{
			MethodName: "queryStation",
			Handler:    _Station_QueryStation_Handler,
		},
		{
			MethodName: "getStationAll",
			Handler:    _Station_GetStationAll_Handler,
		},
		{
			MethodName: "getStation",
			Handler:    _Station_GetStation_Handler,
		},
		{
			MethodName: "queryPosts",
			Handler:    _Station_QueryPosts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "station.proto",
}

const (
	Posts_AddPosts_FullMethodName     = "/station.Posts/addPosts"
	Posts_UpdatePosts_FullMethodName  = "/station.Posts/updatePosts"
	Posts_DeletePosts_FullMethodName  = "/station.Posts/deletePosts"
	Posts_QueryPosts_FullMethodName   = "/station.Posts/queryPosts"
	Posts_GetPosts_FullMethodName     = "/station.Posts/getPosts"
	Posts_QueryStation_FullMethodName = "/station.Posts/queryStation"
)

// PostsClient is the client API for Posts service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PostsClient interface {
	AddPosts(ctx context.Context, in *PostsInfo, opts ...grpc.CallOption) (*PostsInfo, error)
	UpdatePosts(ctx context.Context, in *PostsInfo, opts ...grpc.CallOption) (*PostsInfo, error)
	DeletePosts(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error)
	QueryPosts(ctx context.Context, in *PostsReq, opts ...grpc.CallOption) (*PostsListInfo, error)
	GetPosts(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*PostsInfo, error)
	QueryStation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*PostsStationResp, error)
}

type postsClient struct {
	cc grpc.ClientConnInterface
}

func NewPostsClient(cc grpc.ClientConnInterface) PostsClient {
	return &postsClient{cc}
}

func (c *postsClient) AddPosts(ctx context.Context, in *PostsInfo, opts ...grpc.CallOption) (*PostsInfo, error) {
	out := new(PostsInfo)
	err := c.cc.Invoke(ctx, Posts_AddPosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postsClient) UpdatePosts(ctx context.Context, in *PostsInfo, opts ...grpc.CallOption) (*PostsInfo, error) {
	out := new(PostsInfo)
	err := c.cc.Invoke(ctx, Posts_UpdatePosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postsClient) DeletePosts(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error) {
	out := new(BaseDataInfo)
	err := c.cc.Invoke(ctx, Posts_DeletePosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postsClient) QueryPosts(ctx context.Context, in *PostsReq, opts ...grpc.CallOption) (*PostsListInfo, error) {
	out := new(PostsListInfo)
	err := c.cc.Invoke(ctx, Posts_QueryPosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postsClient) GetPosts(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*PostsInfo, error) {
	out := new(PostsInfo)
	err := c.cc.Invoke(ctx, Posts_GetPosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postsClient) QueryStation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*PostsStationResp, error) {
	out := new(PostsStationResp)
	err := c.cc.Invoke(ctx, Posts_QueryStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PostsServer is the server API for Posts service.
// All implementations must embed UnimplementedPostsServer
// for forward compatibility
type PostsServer interface {
	AddPosts(context.Context, *PostsInfo) (*PostsInfo, error)
	UpdatePosts(context.Context, *PostsInfo) (*PostsInfo, error)
	DeletePosts(context.Context, *IDPathReq) (*BaseDataInfo, error)
	QueryPosts(context.Context, *PostsReq) (*PostsListInfo, error)
	GetPosts(context.Context, *IDPathReq) (*PostsInfo, error)
	QueryStation(context.Context, *IDPathReq) (*PostsStationResp, error)
	mustEmbedUnimplementedPostsServer()
}

// UnimplementedPostsServer must be embedded to have forward compatible implementations.
type UnimplementedPostsServer struct {
}

func (UnimplementedPostsServer) AddPosts(context.Context, *PostsInfo) (*PostsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPosts not implemented")
}
func (UnimplementedPostsServer) UpdatePosts(context.Context, *PostsInfo) (*PostsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePosts not implemented")
}
func (UnimplementedPostsServer) DeletePosts(context.Context, *IDPathReq) (*BaseDataInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePosts not implemented")
}
func (UnimplementedPostsServer) QueryPosts(context.Context, *PostsReq) (*PostsListInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPosts not implemented")
}
func (UnimplementedPostsServer) GetPosts(context.Context, *IDPathReq) (*PostsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPosts not implemented")
}
func (UnimplementedPostsServer) QueryStation(context.Context, *IDPathReq) (*PostsStationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStation not implemented")
}
func (UnimplementedPostsServer) mustEmbedUnimplementedPostsServer() {}

// UnsafePostsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PostsServer will
// result in compilation errors.
type UnsafePostsServer interface {
	mustEmbedUnimplementedPostsServer()
}

func RegisterPostsServer(s grpc.ServiceRegistrar, srv PostsServer) {
	s.RegisterService(&Posts_ServiceDesc, srv)
}

func _Posts_AddPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostsServer).AddPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Posts_AddPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostsServer).AddPosts(ctx, req.(*PostsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Posts_UpdatePosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostsServer).UpdatePosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Posts_UpdatePosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostsServer).UpdatePosts(ctx, req.(*PostsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Posts_DeletePosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostsServer).DeletePosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Posts_DeletePosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostsServer).DeletePosts(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Posts_QueryPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostsServer).QueryPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Posts_QueryPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostsServer).QueryPosts(ctx, req.(*PostsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Posts_GetPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostsServer).GetPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Posts_GetPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostsServer).GetPosts(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Posts_QueryStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostsServer).QueryStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Posts_QueryStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostsServer).QueryStation(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Posts_ServiceDesc is the grpc.ServiceDesc for Posts service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Posts_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "station.Posts",
	HandlerType: (*PostsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addPosts",
			Handler:    _Posts_AddPosts_Handler,
		},
		{
			MethodName: "updatePosts",
			Handler:    _Posts_UpdatePosts_Handler,
		},
		{
			MethodName: "deletePosts",
			Handler:    _Posts_DeletePosts_Handler,
		},
		{
			MethodName: "queryPosts",
			Handler:    _Posts_QueryPosts_Handler,
		},
		{
			MethodName: "getPosts",
			Handler:    _Posts_GetPosts_Handler,
		},
		{
			MethodName: "queryStation",
			Handler:    _Posts_QueryStation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "station.proto",
}

const (
	DeliveryLog_AddDelivery_FullMethodName       = "/station.DeliveryLog/addDelivery"
	DeliveryLog_GetDeliveryList_FullMethodName   = "/station.DeliveryLog/getDeliveryList"
	DeliveryLog_AddDeliveryLog_FullMethodName    = "/station.DeliveryLog/addDeliveryLog"
	DeliveryLog_UpdateDeliveryLog_FullMethodName = "/station.DeliveryLog/updateDeliveryLog"
	DeliveryLog_UpdateStatus_FullMethodName      = "/station.DeliveryLog/updateStatus"
	DeliveryLog_DeleteDeliveryLog_FullMethodName = "/station.DeliveryLog/deleteDeliveryLog"
	DeliveryLog_QueryDeliveryLog_FullMethodName  = "/station.DeliveryLog/queryDeliveryLog"
)

// DeliveryLogClient is the client API for DeliveryLog service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeliveryLogClient interface {
	AddDelivery(ctx context.Context, in *DeliveryLogListInfo, opts ...grpc.CallOption) (*BaseDataInfo, error)
	GetDeliveryList(ctx context.Context, in *DeliveryInfo, opts ...grpc.CallOption) (*DeliveryLogListInfo, error)
	AddDeliveryLog(ctx context.Context, in *DeliveryLogInfo, opts ...grpc.CallOption) (*DeliveryLogInfo, error)
	UpdateDeliveryLog(ctx context.Context, in *DeliveryLogInfo, opts ...grpc.CallOption) (*DeliveryLogInfo, error)
	UpdateStatus(ctx context.Context, in *IDStatusReq, opts ...grpc.CallOption) (*BaseDataInfo, error)
	DeleteDeliveryLog(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error)
	QueryDeliveryLog(ctx context.Context, in *DeliveryLogReq, opts ...grpc.CallOption) (*DeliveryLogListInfo, error)
}

type deliveryLogClient struct {
	cc grpc.ClientConnInterface
}

func NewDeliveryLogClient(cc grpc.ClientConnInterface) DeliveryLogClient {
	return &deliveryLogClient{cc}
}

func (c *deliveryLogClient) AddDelivery(ctx context.Context, in *DeliveryLogListInfo, opts ...grpc.CallOption) (*BaseDataInfo, error) {
	out := new(BaseDataInfo)
	err := c.cc.Invoke(ctx, DeliveryLog_AddDelivery_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deliveryLogClient) GetDeliveryList(ctx context.Context, in *DeliveryInfo, opts ...grpc.CallOption) (*DeliveryLogListInfo, error) {
	out := new(DeliveryLogListInfo)
	err := c.cc.Invoke(ctx, DeliveryLog_GetDeliveryList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deliveryLogClient) AddDeliveryLog(ctx context.Context, in *DeliveryLogInfo, opts ...grpc.CallOption) (*DeliveryLogInfo, error) {
	out := new(DeliveryLogInfo)
	err := c.cc.Invoke(ctx, DeliveryLog_AddDeliveryLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deliveryLogClient) UpdateDeliveryLog(ctx context.Context, in *DeliveryLogInfo, opts ...grpc.CallOption) (*DeliveryLogInfo, error) {
	out := new(DeliveryLogInfo)
	err := c.cc.Invoke(ctx, DeliveryLog_UpdateDeliveryLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deliveryLogClient) UpdateStatus(ctx context.Context, in *IDStatusReq, opts ...grpc.CallOption) (*BaseDataInfo, error) {
	out := new(BaseDataInfo)
	err := c.cc.Invoke(ctx, DeliveryLog_UpdateStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deliveryLogClient) DeleteDeliveryLog(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error) {
	out := new(BaseDataInfo)
	err := c.cc.Invoke(ctx, DeliveryLog_DeleteDeliveryLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deliveryLogClient) QueryDeliveryLog(ctx context.Context, in *DeliveryLogReq, opts ...grpc.CallOption) (*DeliveryLogListInfo, error) {
	out := new(DeliveryLogListInfo)
	err := c.cc.Invoke(ctx, DeliveryLog_QueryDeliveryLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeliveryLogServer is the server API for DeliveryLog service.
// All implementations must embed UnimplementedDeliveryLogServer
// for forward compatibility
type DeliveryLogServer interface {
	AddDelivery(context.Context, *DeliveryLogListInfo) (*BaseDataInfo, error)
	GetDeliveryList(context.Context, *DeliveryInfo) (*DeliveryLogListInfo, error)
	AddDeliveryLog(context.Context, *DeliveryLogInfo) (*DeliveryLogInfo, error)
	UpdateDeliveryLog(context.Context, *DeliveryLogInfo) (*DeliveryLogInfo, error)
	UpdateStatus(context.Context, *IDStatusReq) (*BaseDataInfo, error)
	DeleteDeliveryLog(context.Context, *IDPathReq) (*BaseDataInfo, error)
	QueryDeliveryLog(context.Context, *DeliveryLogReq) (*DeliveryLogListInfo, error)
	mustEmbedUnimplementedDeliveryLogServer()
}

// UnimplementedDeliveryLogServer must be embedded to have forward compatible implementations.
type UnimplementedDeliveryLogServer struct {
}

func (UnimplementedDeliveryLogServer) AddDelivery(context.Context, *DeliveryLogListInfo) (*BaseDataInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDelivery not implemented")
}
func (UnimplementedDeliveryLogServer) GetDeliveryList(context.Context, *DeliveryInfo) (*DeliveryLogListInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeliveryList not implemented")
}
func (UnimplementedDeliveryLogServer) AddDeliveryLog(context.Context, *DeliveryLogInfo) (*DeliveryLogInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDeliveryLog not implemented")
}
func (UnimplementedDeliveryLogServer) UpdateDeliveryLog(context.Context, *DeliveryLogInfo) (*DeliveryLogInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeliveryLog not implemented")
}
func (UnimplementedDeliveryLogServer) UpdateStatus(context.Context, *IDStatusReq) (*BaseDataInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedDeliveryLogServer) DeleteDeliveryLog(context.Context, *IDPathReq) (*BaseDataInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDeliveryLog not implemented")
}
func (UnimplementedDeliveryLogServer) QueryDeliveryLog(context.Context, *DeliveryLogReq) (*DeliveryLogListInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDeliveryLog not implemented")
}
func (UnimplementedDeliveryLogServer) mustEmbedUnimplementedDeliveryLogServer() {}

// UnsafeDeliveryLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeliveryLogServer will
// result in compilation errors.
type UnsafeDeliveryLogServer interface {
	mustEmbedUnimplementedDeliveryLogServer()
}

func RegisterDeliveryLogServer(s grpc.ServiceRegistrar, srv DeliveryLogServer) {
	s.RegisterService(&DeliveryLog_ServiceDesc, srv)
}

func _DeliveryLog_AddDelivery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliveryLogListInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryLogServer).AddDelivery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeliveryLog_AddDelivery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryLogServer).AddDelivery(ctx, req.(*DeliveryLogListInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeliveryLog_GetDeliveryList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliveryInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryLogServer).GetDeliveryList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeliveryLog_GetDeliveryList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryLogServer).GetDeliveryList(ctx, req.(*DeliveryInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeliveryLog_AddDeliveryLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliveryLogInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryLogServer).AddDeliveryLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeliveryLog_AddDeliveryLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryLogServer).AddDeliveryLog(ctx, req.(*DeliveryLogInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeliveryLog_UpdateDeliveryLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliveryLogInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryLogServer).UpdateDeliveryLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeliveryLog_UpdateDeliveryLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryLogServer).UpdateDeliveryLog(ctx, req.(*DeliveryLogInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeliveryLog_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryLogServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeliveryLog_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryLogServer).UpdateStatus(ctx, req.(*IDStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeliveryLog_DeleteDeliveryLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryLogServer).DeleteDeliveryLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeliveryLog_DeleteDeliveryLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryLogServer).DeleteDeliveryLog(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeliveryLog_QueryDeliveryLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliveryLogReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryLogServer).QueryDeliveryLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeliveryLog_QueryDeliveryLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryLogServer).QueryDeliveryLog(ctx, req.(*DeliveryLogReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DeliveryLog_ServiceDesc is the grpc.ServiceDesc for DeliveryLog service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeliveryLog_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "station.DeliveryLog",
	HandlerType: (*DeliveryLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addDelivery",
			Handler:    _DeliveryLog_AddDelivery_Handler,
		},
		{
			MethodName: "getDeliveryList",
			Handler:    _DeliveryLog_GetDeliveryList_Handler,
		},
		{
			MethodName: "addDeliveryLog",
			Handler:    _DeliveryLog_AddDeliveryLog_Handler,
		},
		{
			MethodName: "updateDeliveryLog",
			Handler:    _DeliveryLog_UpdateDeliveryLog_Handler,
		},
		{
			MethodName: "updateStatus",
			Handler:    _DeliveryLog_UpdateStatus_Handler,
		},
		{
			MethodName: "deleteDeliveryLog",
			Handler:    _DeliveryLog_DeleteDeliveryLog_Handler,
		},
		{
			MethodName: "queryDeliveryLog",
			Handler:    _DeliveryLog_QueryDeliveryLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "station.proto",
}

const (
	StationPostsRelation_AddStationPostsRelation_FullMethodName    = "/station.StationPostsRelation/addStationPostsRelation"
	StationPostsRelation_UpdateStationPostsRelation_FullMethodName = "/station.StationPostsRelation/updateStationPostsRelation"
	StationPostsRelation_DeleteStationPostsRelation_FullMethodName = "/station.StationPostsRelation/deleteStationPostsRelation"
)

// StationPostsRelationClient is the client API for StationPostsRelation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StationPostsRelationClient interface {
	AddStationPostsRelation(ctx context.Context, in *StationPostsRelationInfo, opts ...grpc.CallOption) (*StationPostsRelationInfo, error)
	UpdateStationPostsRelation(ctx context.Context, in *StationPostsRelationInfo, opts ...grpc.CallOption) (*StationPostsRelationInfo, error)
	DeleteStationPostsRelation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error)
}

type stationPostsRelationClient struct {
	cc grpc.ClientConnInterface
}

func NewStationPostsRelationClient(cc grpc.ClientConnInterface) StationPostsRelationClient {
	return &stationPostsRelationClient{cc}
}

func (c *stationPostsRelationClient) AddStationPostsRelation(ctx context.Context, in *StationPostsRelationInfo, opts ...grpc.CallOption) (*StationPostsRelationInfo, error) {
	out := new(StationPostsRelationInfo)
	err := c.cc.Invoke(ctx, StationPostsRelation_AddStationPostsRelation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationPostsRelationClient) UpdateStationPostsRelation(ctx context.Context, in *StationPostsRelationInfo, opts ...grpc.CallOption) (*StationPostsRelationInfo, error) {
	out := new(StationPostsRelationInfo)
	err := c.cc.Invoke(ctx, StationPostsRelation_UpdateStationPostsRelation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationPostsRelationClient) DeleteStationPostsRelation(ctx context.Context, in *IDPathReq, opts ...grpc.CallOption) (*BaseDataInfo, error) {
	out := new(BaseDataInfo)
	err := c.cc.Invoke(ctx, StationPostsRelation_DeleteStationPostsRelation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StationPostsRelationServer is the server API for StationPostsRelation service.
// All implementations must embed UnimplementedStationPostsRelationServer
// for forward compatibility
type StationPostsRelationServer interface {
	AddStationPostsRelation(context.Context, *StationPostsRelationInfo) (*StationPostsRelationInfo, error)
	UpdateStationPostsRelation(context.Context, *StationPostsRelationInfo) (*StationPostsRelationInfo, error)
	DeleteStationPostsRelation(context.Context, *IDPathReq) (*BaseDataInfo, error)
	mustEmbedUnimplementedStationPostsRelationServer()
}

// UnimplementedStationPostsRelationServer must be embedded to have forward compatible implementations.
type UnimplementedStationPostsRelationServer struct {
}

func (UnimplementedStationPostsRelationServer) AddStationPostsRelation(context.Context, *StationPostsRelationInfo) (*StationPostsRelationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddStationPostsRelation not implemented")
}
func (UnimplementedStationPostsRelationServer) UpdateStationPostsRelation(context.Context, *StationPostsRelationInfo) (*StationPostsRelationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStationPostsRelation not implemented")
}
func (UnimplementedStationPostsRelationServer) DeleteStationPostsRelation(context.Context, *IDPathReq) (*BaseDataInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStationPostsRelation not implemented")
}
func (UnimplementedStationPostsRelationServer) mustEmbedUnimplementedStationPostsRelationServer() {}

// UnsafeStationPostsRelationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StationPostsRelationServer will
// result in compilation errors.
type UnsafeStationPostsRelationServer interface {
	mustEmbedUnimplementedStationPostsRelationServer()
}

func RegisterStationPostsRelationServer(s grpc.ServiceRegistrar, srv StationPostsRelationServer) {
	s.RegisterService(&StationPostsRelation_ServiceDesc, srv)
}

func _StationPostsRelation_AddStationPostsRelation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationPostsRelationInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationPostsRelationServer).AddStationPostsRelation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StationPostsRelation_AddStationPostsRelation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationPostsRelationServer).AddStationPostsRelation(ctx, req.(*StationPostsRelationInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _StationPostsRelation_UpdateStationPostsRelation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationPostsRelationInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationPostsRelationServer).UpdateStationPostsRelation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StationPostsRelation_UpdateStationPostsRelation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationPostsRelationServer).UpdateStationPostsRelation(ctx, req.(*StationPostsRelationInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _StationPostsRelation_DeleteStationPostsRelation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationPostsRelationServer).DeleteStationPostsRelation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StationPostsRelation_DeleteStationPostsRelation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationPostsRelationServer).DeleteStationPostsRelation(ctx, req.(*IDPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

// StationPostsRelation_ServiceDesc is the grpc.ServiceDesc for StationPostsRelation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StationPostsRelation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "station.StationPostsRelation",
	HandlerType: (*StationPostsRelationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addStationPostsRelation",
			Handler:    _StationPostsRelation_AddStationPostsRelation_Handler,
		},
		{
			MethodName: "updateStationPostsRelation",
			Handler:    _StationPostsRelation_UpdateStationPostsRelation_Handler,
		},
		{
			MethodName: "deleteStationPostsRelation",
			Handler:    _StationPostsRelation_DeleteStationPostsRelation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "station.proto",
}
